'use strict'

const StorageWatcher = require('../../Watchers/Storage/StorageWatcher')
const POSITIVE_EVENTS = Array.from(['add', 'change', 'addDir'])
const NEGATIVE_EVENTS = Array.from(['unlink', 'unlinkDir'])

const FileHasher = require('../../Utility/FileHasher')
const LogHandler = require('../../Handlers/Log/LogHandler')

const fs = require('../../../Overrides/fs')
const path = require('../../../Overrides/path')

module.exports = class StorageWorker {
  constructor (StorageInterface, DatabaseInterface) {
    this.StorageInterface = StorageInterface
    this.StorageWatcher = new StorageWatcher(this.StorageInterface)

    this.DatabaseInterface = DatabaseInterface
  }

  go () {
    this.StorageWatcher.go()

    this.StorageWatcher.MessageQueue.on('new', (item) => {
      this.eventHandler(item)
    })
    // @todo: use async package to handle indexing of files
    // @todo: use propper message queue to only invoke n events at the "same" time
  }

  eventHandler (item) {
    if (POSITIVE_EVENTS.indexOf(item.event) > -1) {
      this.handlePositiveEvent(item.path)
    }
    if (NEGATIVE_EVENTS.indexOf(item.event) > -1) {
      this.handleNegativeEvent(item.path)
    }
  }

  handlePositiveEvent (path) {
    // (re-)index item.path
    return new Promise((resolve, reject) => {
      fs.statPromise(path).then((stats) => {
        if (stats.isFile()) {
          this.handlePositiveFile(path, stats)
            .then((file) => {
              resolve(file)
            }).catch((err) => {
              reject(err)
          })
        }

        if (stats.isDirectory()) {
          this.handlePositiveDirectory(path, stats)
            .then((file) => {
              resolve(file)
            }).catch((err) => {
              reject(err)
            })
        }
      }).catch((err) => {
        LogHandler.error(err)
        reject(err)
      })
    })
  }

  handleNegativeEvent (path) {
    // delete item.path
    LogHandler.debug(path)
  }

  /**
   * Handles indexing of one single file
   * @since 1.0.0
   * @param {string} absolutePath Absolute path of current file
   * @param {fs.Stats} stats Current file information
   * @return {Promise<any>} Resolves when file object was successfully added
   * @todo: not only handle local files here but use this.StorageInterface to
   * @todo: get what is required!
   */
  handlePositiveFile (absolutePath, stats) {
    return new Promise((resolve, reject) => {
      new FileHasher(absolutePath).then((hash) => {
        let relativePath = this.getRelativePathFromAbsolute(absolutePath)
        let file = this.prepareFile(relativePath, stats, hash)

        this.DatabaseInterface.addOrUpdatePath(file).then((file) => {
          resolve(file)
        })

      }).catch((err) => {
        LogHandler.error(err)
        reject(err)
      })
    })
  }

  /**
   * Handle indexing of one single directory
   * @since 1.0.0
   * @param {string} absolutePath Absolute path of current file
   * @return {Promise<any>} Resolves when folder object was successfully added
   */
  handlePositiveDirectory (absolutePath) {
    return new Promise((resolve) => {
      let relativePath = this.getRelativePathFromAbsolute(absolutePath)
      let directory = this.prepareDirectory(relativePath)

      this.DatabaseInterface.addOrUpdatePath(directory).then((directory) => {
        resolve(directory)
      })
    })
  }

  /**
   * Prepares a filelist entry of type file
   * @since 1.0.0
   * @param {string} relativePath Relative path of current file
   * @param {fs.Stats} stats Current file information
   * @param {string} hash Current file hash generated by fileHasher
   * @returns {Object.<tring,(number|string)>} File object
   */
  prepareFile (relativePath, stats, hash) {
    return {
      '.tag': 'file',
      name: path.basename(relativePath),
      path_lower: relativePath.toLowerCase(),
      path_display: relativePath,
      client_modified: stats.mtime,
      size: stats.size,
      content_hash: hash,
      rev: ''
    }
  }

  /**
   * Prepares a filelist entry of type directory
   * @since 1.0.0
   * @param {string} relativePath Relative path of current directory
   * @returns {Object.<string,(string|number)>} Directory object
   */
  prepareDirectory (relativePath) {
    return {
      '.tag': 'folder',
      name: path.basename(relativePath),
      path_lower: relativePath.toLowerCase(),
      path_display: relativePath
    }
  }

  /**
   * Computes a relative path from a given absolute path
   * @since 1.0.0
   * @param {string} absolutePath Absolute path to be resolved
   * @returns {string} Relative path from `absoltuePath`
   */
  getRelativePathFromAbsolute (absolutePath) {
    return path.addLeadingSlash(
      path.relatify(absolutePath, this.StorageInterface.storagePath)
    )
  }

  /**
   * Computes an absolute path from a given relative path
   * @since 1.0.0
   * @param {string} relativePath Relative path to be resolved
   * @returns {string} Absolute path from `relativePath`
   */
  getAbsolutePathFromRelative (relativePath) {
    return path.join(this.StorageInterface.storagePath, relativePath)
  }
}